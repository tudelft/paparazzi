/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: evalObjAndConstrAndDerivatives.c
 *
 * MATLAB Coder version            : 23.2
 * C/C++ source code generated on  : 12-Jun-2024 14:47:14
 */

/* Include Files */
#include "evalObjAndConstrAndDerivatives.h"
#include "checkMatrixNonFinite.h"
#include "checkVectorNonFinite.h"
#include "path_optimizer_fcn.h"
#include "path_optimizer_fcn_types.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <string.h>

/* Function Definitions */
/*
 * Arguments    : const double c_obj_next_next_next_next_next_[3]
 *                const double d_obj_next_next_next_next_next_[3]
 *                const double e_obj_next_next_next_next_next_[3]
 *                const double f_obj_next_next_next_next_next_[3]
 *                const double g_obj_next_next_next_next_next_[3]
 *                const double h_obj_next_next_next_next_next_[3]
 *                const double i_obj_next_next_next_next_next_[3]
 *                double j_obj_next_next_next_next_next_
 *                double k_obj_next_next_next_next_next_
 *                const double l_obj_next_next_next_next_next_[18]
 *                double m_obj_next_next_next_next_next_
 *                double n_obj_next_next_next_next_next_
 *                double o_obj_next_next_next_next_next_
 *                const double x[18]
 *                double grad_workspace_data[]
 *                double Cineq_workspace_data[]
 *                double Ceq_workspace_data[]
 *                int *Ceq_workspace_size
 *                emxArray_real_T *JacIneqTrans_workspace
 *                double JacEqTrans_workspace_data[]
 *                int *JacEqTrans_workspace_size
 *                int *status
 * Return Type  : double
 */
double evalObjAndConstrAndDerivatives(
    const double c_obj_next_next_next_next_next_[3],
    const double d_obj_next_next_next_next_next_[3],
    const double e_obj_next_next_next_next_next_[3],
    const double f_obj_next_next_next_next_next_[3],
    const double g_obj_next_next_next_next_next_[3],
    const double h_obj_next_next_next_next_next_[3],
    const double i_obj_next_next_next_next_next_[3],
    double j_obj_next_next_next_next_next_,
    double k_obj_next_next_next_next_next_,
    const double l_obj_next_next_next_next_next_[18],
    double m_obj_next_next_next_next_next_,
    double n_obj_next_next_next_next_next_,
    double o_obj_next_next_next_next_next_, const double x[18],
    double grad_workspace_data[], double Cineq_workspace_data[],
    double Ceq_workspace_data[], int *Ceq_workspace_size,
    emxArray_real_T *JacIneqTrans_workspace, double JacEqTrans_workspace_data[],
    int *JacEqTrans_workspace_size, int *status)
{
  emxArray_real_T b_JacEqTrans_workspace_data;
  double varargout_3_data[2304];
  double varargout_4_data[324];
  double varargout_1_data[128];
  double cost_gradient[18];
  double fval;
  double *JacIneqTrans_workspace_data;
  int idx_col;
  int idx_current;
  bool allFinite;
  JacIneqTrans_workspace_data = JacIneqTrans_workspace->data;
  /*  Objective function for minimizing time (quadratic) */
  /*  Maximize smoothness */
  /* COMPUTE_COST_AND_GRADIENT_OPTIMAL_PATH */
  /*     [COST,COST_GRADIENT] =
   * COMPUTE_COST_AND_GRADIENT_OPTIMAL_PATH(coeff_1_UAV,coeff_2_UAV,coeff_3_UAV,coeff_4_UAV,coeff_5_UAV,coeff_7_UAV,coeff_8_UAV,coeff_9_UAV,coeff_10_UAV,coeff_11_UAV,coeff_13_UAV,coeff_14_UAV,coeff_15_UAV,coeff_16_UAV,coeff_17_UAV)
   */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     12-Jun-2024 13:42:22 */
  fval = (((((((((((((x[0] * x[0] + x[1] * x[1]) + x[2] * x[2]) + x[3] * x[3]) +
                   x[4] * x[4]) +
                  x[6] * x[6]) +
                 x[7] * x[7]) +
                x[8] * x[8]) +
               x[9] * x[9]) +
              x[10] * x[10]) +
             x[12] * x[12]) +
            x[13] * x[13]) +
           x[14] * x[14]) +
          x[15] * x[15]) +
         x[16] * x[16];
  cost_gradient[0] = x[0] * 2.0;
  cost_gradient[1] = x[1] * 2.0;
  cost_gradient[2] = x[2] * 2.0;
  cost_gradient[3] = x[3] * 2.0;
  cost_gradient[4] = x[4] * 2.0;
  cost_gradient[5] = 0.0;
  cost_gradient[6] = x[6] * 2.0;
  cost_gradient[7] = x[7] * 2.0;
  cost_gradient[8] = x[8] * 2.0;
  cost_gradient[9] = x[9] * 2.0;
  cost_gradient[10] = x[10] * 2.0;
  cost_gradient[11] = 0.0;
  cost_gradient[12] = x[12] * 2.0;
  cost_gradient[13] = x[13] * 2.0;
  cost_gradient[14] = x[14] * 2.0;
  cost_gradient[15] = x[15] * 2.0;
  cost_gradient[16] = x[16] * 2.0;
  cost_gradient[17] = 0.0;
  memcpy(&grad_workspace_data[0], &cost_gradient[0], 18U * sizeof(double));
  *status = 1;
  allFinite = rtIsNaN(fval);
  if (rtIsInf(fval) || allFinite) {
    if (allFinite) {
      *status = -3;
    } else if (fval < 0.0) {
      *status = -1;
    } else {
      *status = -2;
    }
  } else {
    allFinite = true;
    idx_current = 0;
    while (allFinite && (idx_current + 1 <= 18)) {
      allFinite = ((!rtIsInf(grad_workspace_data[idx_current])) &&
                   (!rtIsNaN(grad_workspace_data[idx_current])));
      idx_current++;
    }
    if (!allFinite) {
      idx_current--;
      if (rtIsNaN(grad_workspace_data[idx_current])) {
        *status = -3;
      } else if (grad_workspace_data[idx_current] < 0.0) {
        *status = -1;
      } else {
        *status = -2;
      }
    }
  }
  if (*status == 1) {
    double y_data[183];
    int varargout_1_size[2];
    int varargout_2_size[2];
    int varargout_3_size[2];
    int varargout_4_size[2];
    path_optimizer_fcn_anonFcn2(
        c_obj_next_next_next_next_next_, d_obj_next_next_next_next_next_,
        e_obj_next_next_next_next_next_, f_obj_next_next_next_next_next_,
        g_obj_next_next_next_next_next_, h_obj_next_next_next_next_next_,
        i_obj_next_next_next_next_next_, j_obj_next_next_next_next_next_,
        k_obj_next_next_next_next_next_, l_obj_next_next_next_next_next_,
        m_obj_next_next_next_next_next_, n_obj_next_next_next_next_next_,
        o_obj_next_next_next_next_next_, x, varargout_1_data, varargout_1_size,
        cost_gradient, varargout_2_size, varargout_3_data, varargout_3_size,
        varargout_4_data, varargout_4_size);
    memcpy(&Cineq_workspace_data[0], &varargout_1_data[0],
           128U * sizeof(double));
    *Ceq_workspace_size = 18;
    for (idx_current = 0; idx_current < 18; idx_current++) {
      double d;
      d = cost_gradient[idx_current];
      y_data[idx_current] = d;
      Ceq_workspace_data[idx_current] = d;
    }
    for (idx_current = 0; idx_current < 18; idx_current++) {
      for (idx_col = 0; idx_col < 128; idx_col++) {
        JacIneqTrans_workspace_data[idx_current + 183 * idx_col] =
            varargout_3_data[idx_current + 18 * idx_col];
      }
    }
    for (idx_current = 0; idx_current < 18; idx_current++) {
      for (idx_col = 0; idx_col < 18; idx_col++) {
        JacEqTrans_workspace_data[idx_current + 183 * idx_col] =
            varargout_4_data[idx_current + 18 * idx_col];
      }
    }
    *status = checkVectorNonFinite(128, Cineq_workspace_data);
    if (*status == 1) {
      *status = checkVectorNonFinite(18, y_data);
      if (*status == 1) {
        *status = checkMatrixNonFinite(128, JacIneqTrans_workspace);
        if (*status == 1) {
          b_JacEqTrans_workspace_data.data = &JacEqTrans_workspace_data[0];
          b_JacEqTrans_workspace_data.size = JacEqTrans_workspace_size;
          b_JacEqTrans_workspace_data.allocatedSize = -1;
          b_JacEqTrans_workspace_data.numDimensions = 1;
          b_JacEqTrans_workspace_data.canFreeData = false;
          *status = checkMatrixNonFinite(18, &b_JacEqTrans_workspace_data);
        }
      }
    }
  }
  return fval;
}

/*
 * File trailer for evalObjAndConstrAndDerivatives.c
 *
 * [EOF]
 */
