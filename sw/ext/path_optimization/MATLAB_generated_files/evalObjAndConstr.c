/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: evalObjAndConstr.c
 *
 * MATLAB Coder version            : 23.2
 * C/C++ source code generated on  : 12-Jun-2024 14:47:14
 */

/* Include Files */
#include "evalObjAndConstr.h"
#include "checkVectorNonFinite.h"
#include "compute_constraints_and_constraints_gradient_w_ship_coeff.h"
#include "linspace.h"
#include "path_optimizer_fcn_emxutil.h"
#include "path_optimizer_fcn_types.h"
#include "rt_nonfinite.h"
#include "rt_nonfinite.h"
#include <string.h>

/* Function Definitions */
/*
 * Arguments    : const double c_obj_next_next_next_next_next_[3]
 *                const double d_obj_next_next_next_next_next_[3]
 *                const double e_obj_next_next_next_next_next_[3]
 *                const double f_obj_next_next_next_next_next_[3]
 *                const double g_obj_next_next_next_next_next_[3]
 *                const double h_obj_next_next_next_next_next_[3]
 *                const double i_obj_next_next_next_next_next_[3]
 *                double j_obj_next_next_next_next_next_
 *                double k_obj_next_next_next_next_next_
 *                const double l_obj_next_next_next_next_next_[18]
 *                double m_obj_next_next_next_next_next_
 *                double n_obj_next_next_next_next_next_
 *                double o_obj_next_next_next_next_next_
 *                const double x[18]
 *                double Cineq_workspace_data[]
 *                double Ceq_workspace_data[]
 *                int *status
 * Return Type  : double
 */
double evalObjAndConstr(const double c_obj_next_next_next_next_next_[3],
                        const double d_obj_next_next_next_next_next_[3],
                        const double e_obj_next_next_next_next_next_[3],
                        const double f_obj_next_next_next_next_next_[3],
                        const double g_obj_next_next_next_next_next_[3],
                        const double h_obj_next_next_next_next_next_[3],
                        const double i_obj_next_next_next_next_next_[3],
                        double j_obj_next_next_next_next_next_,
                        double k_obj_next_next_next_next_next_,
                        const double l_obj_next_next_next_next_next_[18],
                        double m_obj_next_next_next_next_next_,
                        double n_obj_next_next_next_next_next_,
                        double o_obj_next_next_next_next_next_,
                        const double x[18], double Cineq_workspace_data[],
                        double Ceq_workspace_data[], int *status)
{
  emxArray_real_T *t_array;
  creal_T c_gradient_data[2304];
  double ceq_gradient_data[324];
  double c_data[128];
  double ceq_data[18];
  double fval;
  double *t_array_data;
  int k;
  int yk;
  bool b;
  /*  Objective function for minimizing time (quadratic) */
  /*  Maximize smoothness */
  /* COMPUTE_COST_AND_GRADIENT_OPTIMAL_PATH */
  /*     [COST,COST_GRADIENT] =
   * COMPUTE_COST_AND_GRADIENT_OPTIMAL_PATH(coeff_1_UAV,coeff_2_UAV,coeff_3_UAV,coeff_4_UAV,coeff_5_UAV,coeff_7_UAV,coeff_8_UAV,coeff_9_UAV,coeff_10_UAV,coeff_11_UAV,coeff_13_UAV,coeff_14_UAV,coeff_15_UAV,coeff_16_UAV,coeff_17_UAV)
   */
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     12-Jun-2024 13:42:22 */
  fval = (((((((((((((x[0] * x[0] + x[1] * x[1]) + x[2] * x[2]) + x[3] * x[3]) +
                   x[4] * x[4]) +
                  x[6] * x[6]) +
                 x[7] * x[7]) +
                x[8] * x[8]) +
               x[9] * x[9]) +
              x[10] * x[10]) +
             x[12] * x[12]) +
            x[13] * x[13]) +
           x[14] * x[14]) +
          x[15] * x[15]) +
         x[16] * x[16];
  *status = 1;
  b = rtIsNaN(fval);
  if (rtIsInf(fval) || b) {
    if (b) {
      *status = -3;
    } else if (fval < 0.0) {
      *status = -1;
    } else {
      *status = -2;
    }
  }
  if (*status == 1) {
    signed char b_y_data[128];
    unsigned char y_data[128];
    y_data[0] = 0U;
    yk = 0;
    for (k = 0; k < 127; k++) {
      yk++;
      y_data[k + 1] = (unsigned char)yk;
    }
    b_y_data[0] = 0;
    yk = 0;
    for (k = 0; k < 17; k++) {
      yk++;
      b_y_data[k + 1] = (signed char)yk;
    }
    int c_gradient_size[2];
    int c_size[2];
    int ceq_gradient_size[2];
    int ceq_size[2];
    /*  Path constraints function for quadratic path */
    emxInit_real_T(&t_array, 2);
    linspace(j_obj_next_next_next_next_next_, k_obj_next_next_next_next_next_,
             t_array);
    t_array_data = t_array->data;
    c_compute_constraints_and_const(
        e_obj_next_next_next_next_next_[0], i_obj_next_next_next_next_next_[0],
        h_obj_next_next_next_next_next_[0], e_obj_next_next_next_next_next_[1],
        i_obj_next_next_next_next_next_[1], h_obj_next_next_next_next_next_[1],
        e_obj_next_next_next_next_next_[2], i_obj_next_next_next_next_next_[2],
        h_obj_next_next_next_next_next_[2], d_obj_next_next_next_next_next_[0],
        g_obj_next_next_next_next_next_[0], f_obj_next_next_next_next_next_[0],
        d_obj_next_next_next_next_next_[1], g_obj_next_next_next_next_next_[1],
        f_obj_next_next_next_next_next_[1], d_obj_next_next_next_next_next_[2],
        g_obj_next_next_next_next_next_[2], f_obj_next_next_next_next_next_[2],
        c_obj_next_next_next_next_next_[0], c_obj_next_next_next_next_next_[1],
        c_obj_next_next_next_next_next_[2], o_obj_next_next_next_next_next_,
        x[0], x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10],
        x[11], x[12], x[13], x[14], x[15], x[16], x[17],
        l_obj_next_next_next_next_next_[0], l_obj_next_next_next_next_next_[1],
        l_obj_next_next_next_next_next_[2], l_obj_next_next_next_next_next_[3],
        l_obj_next_next_next_next_next_[4], l_obj_next_next_next_next_next_[5],
        l_obj_next_next_next_next_next_[6], l_obj_next_next_next_next_next_[7],
        l_obj_next_next_next_next_next_[8], l_obj_next_next_next_next_next_[9],
        l_obj_next_next_next_next_next_[10],
        l_obj_next_next_next_next_next_[11],
        l_obj_next_next_next_next_next_[12],
        l_obj_next_next_next_next_next_[13],
        l_obj_next_next_next_next_next_[14],
        l_obj_next_next_next_next_next_[15],
        l_obj_next_next_next_next_next_[16],
        l_obj_next_next_next_next_next_[17], m_obj_next_next_next_next_next_,
        n_obj_next_next_next_next_next_, t_array_data[1], t_array_data[2],
        t_array_data[3], t_array_data[4], t_array_data[5], t_array_data[6],
        t_array_data[7], t_array_data[8], t_array_data[t_array->size[1] - 1],
        c_data, c_size, ceq_data, ceq_size, c_gradient_data, c_gradient_size,
        ceq_gradient_data, ceq_gradient_size);
    emxFree_real_T(&t_array);
    for (yk = 0; yk < 128; yk++) {
      Cineq_workspace_data[y_data[yk]] = c_data[yk];
    }
    for (yk = 0; yk < 18; yk++) {
      Ceq_workspace_data[b_y_data[yk]] = ceq_data[yk];
    }
    *status = checkVectorNonFinite(128, Cineq_workspace_data);
    if (*status == 1) {
      *status = checkVectorNonFinite(18, Ceq_workspace_data);
    }
  }
  return fval;
}

/*
 * File trailer for evalObjAndConstr.c
 *
 * [EOF]
 */
