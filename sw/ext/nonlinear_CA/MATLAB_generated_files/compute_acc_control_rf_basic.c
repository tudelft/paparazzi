/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: compute_acc_control_rf_basic.c
 *
 * MATLAB Coder version            : 23.2
 * C/C++ source code generated on  : 06-Oct-2024 17:52:32
 */

/* Include Files */
#include "compute_acc_control_rf_basic.h"
#include <math.h>

/* Function Definitions */
/*
 * COMPUTE_ACC_CONTROL_RF_BASIC
 *     ACCELERATIONS_ARRAY =
 * COMPUTE_ACC_CONTROL_RF_BASIC(Beta,CL_aileron,Cd_zero,Cl_alpha,Cm_zero,Cm_alpha,I_xx,I_yy,I_zz,K_Cd,K_p_M,K_p_T,Omega_1,Omega_2,Omega_3,Omega_4,Phi,S,Theta,V,B_1,B_2,B_3,B_4,DELTA_AILERONS,FLIGHT_PATH_ANGLE,G_1,G_2,G_3,G_4,L_1,L_2,L_3,L_4,L_Z,M,P,Q,R,RHO,WING_CHORD)
 *
 * Arguments    : double Beta
 *                double CL_aileron
 *                double Cd_zero
 *                double Cl_alpha
 *                double Cm_zero
 *                double Cm_alpha
 *                double I_xx
 *                double I_yy
 *                double I_zz
 *                double K_Cd
 *                double K_p_M
 *                double K_p_T
 *                double Omega_1
 *                double Omega_2
 *                double Omega_3
 *                double Omega_4
 *                double Phi
 *                double S
 *                double Theta
 *                double V
 *                double b_1
 *                double b_2
 *                double b_3
 *                double b_4
 *                double delta_ailerons
 *                double flight_path_angle
 *                double g_1
 *                double g_2
 *                double g_3
 *                double g_4
 *                double l_1
 *                double l_2
 *                double l_3
 *                double l_4
 *                double l_z
 *                double m
 *                double p
 *                double q
 *                double r
 *                double rho
 *                double wing_chord
 *                double accelerations_array[6]
 * Return Type  : void
 */
void compute_acc_control_rf_basic(
    double Beta, double CL_aileron, double Cd_zero, double Cl_alpha,
    double Cm_zero, double Cm_alpha, double I_xx, double I_yy, double I_zz,
    double K_Cd, double K_p_M, double K_p_T, double Omega_1, double Omega_2,
    double Omega_3, double Omega_4, double Phi, double S, double Theta,
    double V, double b_1, double b_2, double b_3, double b_4,
    double delta_ailerons, double flight_path_angle, double g_1, double g_2,
    double g_3, double g_4, double l_1, double l_2, double l_3, double l_4,
    double l_z, double m, double p, double q, double r, double rho,
    double wing_chord, double accelerations_array[6])
{
  double accelerations_array_tmp;
  double t10;
  double t11;
  double t12;
  double t13;
  double t14;
  double t15;
  double t16;
  double t17;
  double t18;
  double t19;
  double t20;
  double t21;
  double t22;
  double t23;
  double t25;
  double t26;
  double t27;
  double t28;
  double t29;
  double t3;
  double t31;
  double t32;
  double t33;
  double t34;
  double t35;
  double t36;
  double t37;
  double t38;
  double t4;
  double t40;
  double t41;
  double t42;
  double t42_tmp;
  double t43;
  double t43_tmp;
  double t44;
  double t45;
  double t46;
  double t47;
  double t49;
  double t5;
  double t53;
  double t54_tmp_tmp;
  double t56;
  double t57;
  double t58;
  double t6;
  double t7;
  double t8;
  double t9;
  /*     This function was generated by the Symbolic Math Toolbox version 23.2.
   */
  /*     15-May-2024 17:38:01 */
  t3 = cos(Phi);
  t4 = sin(Beta);
  t5 = cos(Theta);
  t6 = sin(Phi);
  t7 = cos(b_1);
  t8 = cos(b_2);
  t9 = cos(b_3);
  t10 = cos(b_4);
  t11 = sin(Theta);
  t12 = cos(g_1);
  t13 = cos(g_2);
  t14 = cos(g_3);
  t15 = cos(g_4);
  t16 = sin(b_1);
  t17 = sin(b_2);
  t18 = sin(b_3);
  t19 = sin(b_4);
  t20 = sin(g_1);
  t21 = sin(g_2);
  t22 = sin(g_3);
  t23 = sin(g_4);
  t25 = Omega_1 * Omega_1;
  t26 = Omega_2 * Omega_2;
  t27 = Omega_3 * Omega_3;
  t28 = Omega_4 * Omega_4;
  t29 = V * V;
  t31 = 1.0 / m;
  t32 = Theta - flight_path_angle;
  t33 = K_p_T * t16 * t25;
  t34 = K_p_T * t17 * t26;
  t35 = K_p_T * t18 * t27;
  t36 = K_p_T * t19 * t28;
  t37 = K_p_T * t7;
  t40 = t37 * t12 * t25;
  t38 = K_p_T * t8;
  t41 = t38 * t13 * t26;
  t42_tmp = K_p_T * t9;
  t42 = t42_tmp * t14 * t27;
  t43_tmp = K_p_T * t10;
  t43 = t43_tmp * t15 * t28;
  t44 = t37 * t20 * t25;
  t45 = t38 * t21 * t26;
  t46 = t42_tmp * t22 * t27;
  t47 = t43_tmp * t23 * t28;
  t37 = cos(t32);
  t38 = sin(t32);
  t53 = ((t33 + t34) + t35) + t36;
  t56 = ((t40 + t41) + t42) + t43;
  t57 = ((t44 + t45) + t46) + t47;
  t42_tmp = Cl_alpha * S * rho * t29 * t32;
  t49 = Cd_zero + K_Cd * (Cl_alpha * Cl_alpha) * (t32 * t32);
  t54_tmp_tmp = S * rho;
  t43_tmp = t54_tmp_tmp * cos(Beta) * t29;
  t58 = t42_tmp * t37 / 2.0 + t43_tmp * t38 * t49 / 2.0;
  accelerations_array_tmp = t3 * t11;
  t42_tmp = t42_tmp * t38 / 2.0 - t43_tmp * t37 * t49 / 2.0;
  t43_tmp = t54_tmp_tmp * t4;
  accelerations_array[0] =
      -t31 * (((((t5 * t53 - t5 * t42_tmp) + accelerations_array_tmp * t56) +
                accelerations_array_tmp * t58) -
               t6 * t11 * t57) +
              t43_tmp * t6 * t11 * t29 * t49 / 2.0);
  accelerations_array[1] = t31 * (((t3 * t57 + t6 * t56) + t6 * t58) -
                                  t54_tmp_tmp * t3 * t4 * t29 * t49 / 2.0);
  accelerations_array_tmp = t3 * t5;
  accelerations_array[2] =
      -t31 * (((((-t11 * t53 + t11 * t42_tmp) + accelerations_array_tmp * t56) +
                accelerations_array_tmp * t58) -
               t5 * t6 * t57) +
              t43_tmp * t5 * t6 * t29 * t49 / 2.0) +
      9.81;
  accelerations_array[3] =
      ((((((((((((((l_1 * t40 - l_1 * t41) - l_2 * t42) + l_2 * t43) +
                 l_z * t44) +
                l_z * t45) +
               l_z * t46) +
              l_z * t47) +
             I_yy * q * r) -
            I_zz * q * r) +
           K_p_M * t16 * t25) -
          K_p_M * t17 * t26) +
         K_p_M * t18 * t27) -
        K_p_M * t19 * t28) +
       CL_aileron * S * delta_ailerons * rho * t29 / 2.0) /
      I_xx;
  accelerations_array_tmp = I_xx * p;
  t42_tmp = K_p_M * t7;
  t43_tmp = K_p_M * t8;
  t38 = K_p_M * t9;
  t37 = K_p_M * t10;
  accelerations_array[4] =
      ((((((((((((((l_4 * t40 - l_3 * t42) + l_4 * t41) - l_3 * t43) +
                 l_z * t33) +
                l_z * t34) +
               l_z * t35) +
              l_z * t36) -
             accelerations_array_tmp * r) +
            I_zz * p * r) -
           t42_tmp * t20 * t25) +
          t43_tmp * t21 * t26) -
         t38 * t22 * t27) +
        t37 * t23 * t28) +
       t54_tmp_tmp * t29 * wing_chord * (Cm_zero + Cm_alpha * t32) / 2.0) /
      I_yy;
  accelerations_array[5] =
      -(((((((((((((l_1 * t33 - l_1 * t34) - l_2 * t35) + l_2 * t36) -
                 l_4 * t44) +
                l_3 * t46) -
               l_4 * t45) +
              l_3 * t47) -
             accelerations_array_tmp * q) +
            I_yy * p * q) -
           t42_tmp * t12 * t25) +
          t43_tmp * t13 * t26) -
         t38 * t14 * t27) +
        t37 * t15 * t28) /
      I_zz;
}

/*
 * Arguments    : void
 * Return Type  : void
 */
void compute_acc_control_rf_basic_initialize(void)
{
}

/*
 * Arguments    : void
 * Return Type  : void
 */
void compute_acc_control_rf_basic_terminate(void)
{
}

/*
 * File trailer for compute_acc_control_rf_basic.c
 *
 * [EOF]
 */
